/**
 * Various utility methods for working with strings.
 *
 * @author Jackson Ray Hamilton
 */
class Strings {

  /**
   * @return Whether or not `a` and `b` are the same string.
   */
  function boolean equals(String a, String b) {
    var int aLength, bLength;
    var int i;

    let aLength = a.length();
    let bLength = b.length();

    // Do the lengths match?
    if (~(aLength = bLength)) {
      return false;
    }

    // Are all the chars the same?
    let i = 0;
    while (i < aLength) {
      if (~(a.charAt(i) = b.charAt(i))) {
        return false;
      }
      let i = i + 1;
    }

    return true;
  }

  /**
   * Mutates a string buffer by adding a sequence of characters to it.
   */
  function void appendToBuffer(String buffer, String string) {
    var int i, length;
    let i = 0;
    let length = string.length();
    while (i < length) {
      do buffer.appendChar(string.charAt(i));
      let i = i + 1;
    }
    return;
  }

  /**
   * @return A string consisting of a substring repeated `amount` times.
   */
  function String repeat(String string, int amount) {
    var int i;
    var Array strings;
    var String ret;

    // Handle case of repeating 0 or fewer times.
    if (~(amount > 0)) {
      return "";
    }

    let strings = Array.new(amount);
    let i = 0;
    while (i < amount) {
      let strings[i] = string;
      let i = i + 1;
    }

    let ret = Strings.join(strings, amount, "");
    do strings.dispose();
    return ret;
  }

  /**
   * Concatenates an array of strings into a single string, joined by a
   * substring.
   *
   * @return A single joined string.
   */
  function String join(Array strings, int stringsLength, String glue) {
    var String ret, string;
    var int retLength, i;

    // Create a string buffer.
    let retLength = 0;
    let i = 0;
    while (i < stringsLength) {
      let string = strings[i];
      let retLength = retLength + string.length();
      let i = i + 1;
    }
    let retLength = retLength + ((stringsLength - 1) * glue.length());
    let ret = String.new(retLength);

    // For each string, append their chars to the buffer.
    let i = 0;
    while (i < stringsLength) {
      if (~(i = 0)) {
        do Strings.appendToBuffer(ret, glue);
      }
      let string = strings[i];
      do Strings.appendToBuffer(ret, string);
      let i = i + 1;
    }

    return ret;
  }

  /**
   * Concatcenates 2 strings together.
   */
  function String concat(String a, String b) {
    var int stringsLength;
    var Array strings;
    var String ret;

    let stringsLength = 2;
    let strings = Array.new(stringsLength);
    let strings[0] = a;
    let strings[1] = b;

    let ret = Strings.join(strings, stringsLength, "");
    do strings.dispose();
    return ret;
  }

  /**
   * Gets the string representation of an int.
   */
  function String coerceInt(int integer) {
    var int temp, length;
    var String buffer;

    // Determine the width of the number.
    let length = 1;
    let temp = Math.abs(integer);
    while ((temp / 10) > 0) {
      let length = length + 1;
      let temp = temp / 10;
    }

    // Negative numbers need space for a negative sign.
    if (integer < 0) {
      let length = length + 1;
    }

    let buffer = String.new(length);
    do buffer.setInt(integer);

    return buffer;
  }

  /**
   * Gets the string representation of a char.
   */
  function String coerceChar(char character) {
    var String buffer;

    let buffer = String.new(1);
    do buffer.appendChar(character);

    return buffer;
  }

  /**
   * Gets the string representation of a boolean.
   */
  function String coerceBoolean(boolean bool) {
    if (bool) {
      return "true";
    } else {
      return "false";
    }
  }

  /**
   * Gets a section of a string.
   *
   * @param string String to get a section of.
   * @param beginIndex Starting index inclusive.
   * @param endIndex Ending index exclusive.
   * @return The section of the string from beginIndex to endIndex.
   */
  function String substring(String string, int beginIndex, int endIndex) {
    var String buffer;
    var int stringLength, size, index;

    let stringLength = string.length();

    // Handle the case of the begin index being out of bounds.
    if (~(beginIndex < stringLength)) {
      return "";
    }

    // Cap the end index at 1 past the end of the string.
    // TODO: Consider whether this is needed or not.
    let endIndex = Math.min(stringLength, endIndex);

    let size = endIndex - beginIndex;
    let buffer = String.new(size);

    let index = beginIndex;
    while (index < endIndex) {
      do buffer.appendChar(string.charAt(index));
      let index = index + 1;
    }

    return buffer;
  }

  /**
   * Searches a string for a substring.
   *
   * @param beginIndex Usually `0`.
   * @return The index of the first occurrence of a substring in a string, or -1
   * if not found.
   */
  function int indexOf(String string, String substring, int beginIndex) {
    var int index, endIndex, stringLength, substringLength;
    var String toCheck;

    let index = beginIndex;
    let stringLength = string.length();
    let substringLength = substring.length();
    while (index < stringLength) {
      let endIndex = index + substringLength;
      let toCheck = Strings.substring(string, index, endIndex);
      if (Strings.equals(substring, toCheck)) {
        do toCheck.dispose();
        return index;
      }
      do toCheck.dispose();
      let index = index + 1;
    }

    return -1;
  }

  /**
   * Gets the first char from a string.
   */
  function char parseChar(String string) {
    return string.charAt(0);
  }

  /**
   * Interpolates values into a string. Similar to C's sprintf.
   *
   * @return The format string interpolated with the given values.
   */
  function String sprintf(String format, Array values) {
    var int index, beginIndex, tagCount, substringsLength, i, substringsIndex;
    var Array substrings;
    var char specifier;
    var String ret;

    let index = 0;
    let beginIndex = index;

    // Count how many tags there are so an array of the correct size
    // can be made.
    let tagCount = 0;
    while (~(index = -1)) {
      let index = Strings.indexOf(format, "%", beginIndex);
      if (index > -1) {
        let tagCount = tagCount + 1;
        let beginIndex = index + 2;
      }
    }

    let substringsLength = 1 + (tagCount * 2);
    let substrings = Array.new(substringsLength);

    let i = 0;
    let substringsIndex = 0;
    let index = 0;
    let beginIndex = index;

    while (~(index = -1)) {
      let index = Strings.indexOf(format, "%", beginIndex);
      if (index > -1) {
        // Get the substring before the tag.
        let substrings[substringsIndex] = Strings.substring(format, beginIndex, index);
        let substringsIndex = substringsIndex + 1;

        // Update beginIndex to point past the tag.
        let beginIndex = index + 2;

        // Determine the next appropriate action based on a specifier.
        // e.g., "%i", "%s", "%c", etc.
        let specifier = format.charAt(index + 1);
        if ((specifier = 105) | (specifier = 100)) { // i || d
          let substrings[substringsIndex] = Strings.coerceInt(values[i]);
        } else {
          if (specifier = 115) { // s
            let substrings[substringsIndex] = values[i];
          } else {
            if (specifier = 99) { // c
              let substrings[substringsIndex] = Strings.coerceChar(values[i]);
            }
          }
        }
        let substringsIndex = substringsIndex + 1;
        let i = i + 1;
      } else {
        let substrings[substringsIndex] = Strings.substring(format, beginIndex,
                                                            format.length());
      }
    }

    // Finally join all the formatted bits together.
    let ret = Strings.join(substrings, substringsLength, "");
    do substrings.dispose();

    return ret;
  }

}
